import{casUpdateData as t,casFetchRows as a,computeFetchData as n,casSetup as o,computeSetup as e,computeSetupTables as l}from"@sassoftware/restaflib";import{initStore as s}from"@sassoftware/restaf";function r(){return r=Object.assign?Object.assign.bind():function(t){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},r.apply(this,arguments)}async function i(t,a,n,o){const{handlers:e}=o.appControl.editControl;if(null==e[t])return[a,{statusCode:0,msg:null}];{const[l,s]=await e[t](a,n,o,t);return[l,s]}}async function u(a,n){let o;return o="cas"===n.source?await async function(a,n){const{store:o,session:e}=n,{table:l,byvars:s}=n.appControl.dataControl,r=n.state.columns,i={};if(null===s||0===s.length)return null;for(const t in a)"_index_"!==t&&!1===r[t].custom&&(i[t]=a[t]);const u={};s.forEach(t=>{u[t]=i[t]});const c={table:l,data:i,where:u};return await t(o,e,c),{statusCode:0,msg:"Save successful"}}(a,n):await async function(t,a){const{store:n,session:o}=a,{table:e,byvars:l}=a.appControl.dataControl;if(null===l||0===l.length)return null;let s=`proc sql; update ${e.libref}.${e.name}`,r="SET ",i=" ";for(const a in t)r=r+i+a+"="+c(t[a]),i=", ";s=s+" "+r;let u=" WHERE ",f=" ";l.forEach(a=>{u=u+f+a+"="+c(t[a]),f="AND "}),s=s+" "+u+";run;";const d=s.split(/\r?\n/);console.log(d);const m={data:{code:d}},p=await n.apiCall(o.links("execute"),m),C=await n.jobState(p,{qs:{newState:"Completed",timeout:1}}),w="completed"===C.data?0:1;return console.log(C),{statusCode:w,msg:C.data}}(a,n),o}function c(t){let a;return a=null==t?".":"string"==typeof t?JSON.stringify(t):t.toString(),a}async function f(t,a,n,o,e){let l=r({},null!==o?o:e.state.data[n]);const s=e.state.columns,{handlers:c,autoSave:f}=e.appControl.editControl;l[t]=function(t,a){let n=t;return"string"!=typeof n||"decimal"!==a.Type&&"number"!==a.Type&&"double"!==a.Type||(n=parseFloat(1*t),!0===isNaN(t)&&(t=0)),n}(a,s[t]);let d={statusCode:0,msg:""};if(null!=c[t]){const a=await c[t](l,t,n,e);if(l=a[0],d=a[1],2===d.statusCode)return{data:a[0],status:d}}let m=await i("main",l,n,e);if(!0===f){if(m=await i("term",m[0],n,e),d=m[1],2===d.statusCode)return{data:m[0],status:d};await u(l,e)}return l=m[0],d.msg=d.msg+" / "+m[1],!0===e.appControl.dataControl.cachePolicy&&(e.state.data[n]=l),{data:l,status:d}}async function d(t,a){const{schema:n,rows:o}=t,e=a.appControl.dataControl.customColumns,l=(t,a)=>{const n={};if(a.forEach((a,o)=>{const e=t[o],l=e.Column.toLowerCase();null==e.Label&&(e.Label=e.Column),n[l]=a}),null!=e)for(const t in e){const a=e[t],o=a.Column.toLowerCase();n[o]=a.value}return n},s=[];for(let t=0;t<o.length;t++){const e=l(n,o[t]),[r,u]=await i("init",e,t,a);0!==u.code&&console.log(JSON.stringify(u,null,4)),s.push(r)}const u={};if(n.forEach((t,a)=>{const n=t.Column.toLowerCase();t.name=n,t.Label=null==t.Label||0===t.Label.length?t.Column:t.Label,t.custom=!1,u[n]=t}),null!=e)for(const t in e){const a=r({},e[t]);a.name=t,a.custom=!0,u[t]=a}return{columns:u,data:s}}async function m(t,o){let e=null;return e="cas"===o.source?await async function(t,n){const{store:o,session:e}=n,l=r({},t);if(null==l.table&&(l.table=n.appControl.dataControl.table),null==l.where&&(l.where={}),l.from<=0||-1===l.next)return null;const s=await a(o,e,l);let i=null;return null!==s&&(i=await d(s.data,n),n.state={modified:[],pagination:r({},s.pagination),currentPage:l,data:[],columns:[]},!0===n.appControl.dataControl.cachePolicy&&(n.state.data=i.data,n.state.columns=i.columns),i.pagination=r({},s.pagination)),i}(t,o):await async function(t,a){const{store:o,tableSummary:e}=a,{table:l}=a.appControl.dataControl,s=`${l.libref}.${l.name}`.toLowerCase();let r={qs:{start:t.from-1,limit:t.count,format:null==t.format&&t.format}};const i=await n(o,e,s,null,r);let u=null;return null!==i&&(u=await d(i,a),a.state={modified:[],pagination:{},currentPage:{},data:u.data,columns:u.columns}),u}(t,o),e}async function p(t,a){let o;return o="cas"===a.source?await async function(t,a){const{initialFetch:n,table:o}=a.appControl.dataControl;let e;if("first"===t)e=r({},n),e.table=o;else if(e=a.state.pagination[t],-1===e.next)return null;return await m(e,a)}(t,a):await async function(t,a){const{store:o,tableSummary:e}=a,{table:l}=a.appControl.dataControl,s=`${l.libref}.${l.name}`.toLowerCase(),r={qs:{limit:a.appControl.dataControl.initialFetch.count}},i=await n(o,e,s,t,r);let u=null;return null!==i&&(u=await d(i,a),a.state={modified:[],pagination:{},currentPage:{},data:u.data,columns:u.columns}),u}(t,a),o}async function C(t,a){const n=s();let r;null==t.authType&&(t.authType="code");const i=a.dataControl;if("cas"===i.source){const a=await o(n,t);r={source:i.source,store:n,session:a.session,servers:a.servers,restaflib:null,logonPayload:t,state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}}}}else{const a=await e(n,null,t);r={store:n,session:a,tableSummary:await l(n,a,i.table),servers:null,restaflib:null,logonPayload:t,state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}}}}return r.appControl=a,r.id=Date(),r}export{f as cellEdit,i as commonHandler,m as fetchTableRows,p as scrollTable,C as setup,u as updateTableRows};
//# sourceMappingURL=index.modern.mjs.map
