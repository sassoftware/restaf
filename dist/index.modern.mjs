import{casUpdateData as t,casFetchRows as a,computeFetchData as n,casSetup as e,computeSetup as o,computeSetupTables as s,caslRun as l,casUpload as r,casAppendTable as i}from"@sassoftware/restaflib";import{initStore as u}from"@sassoftware/restaf";import c from"deepmerge";function f(){return f=Object.assign?Object.assign.bind():function(t){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},f.apply(this,arguments)}async function m(t,a,n,e){const{handlers:o}=e.appControl.editControl;if(null==o[t])return[a,{statusCode:0,msg:null}];{const[s,l]=await o[t](a,n,e,t);return[s,l]}}async function d(a,n){let e;return e="cas"===n.source?await async function(a,n){const{store:e,session:o}=n,{table:s,byvars:l}=n.appControl,r=n.state.columns;if(null===l||0===l.length)return null;const i={};for(const t in a)"_index_"!==t&&"_rowIndex"!==t&&!1===r[t].custom&&(i[t]=a[t]);const u={};l.forEach(t=>{u[t]=i[t]});const c={table:s,data:i,where:u},f={statusCode:0,msg:"Save successful"};return"Normal"!==(await t(e,o,c)).items().toJS().disposition.severity&&(f.statusCode=2,f.msg=i.disposition.severity.reason),f}(a,n):await async function(t,a){const{store:n,session:e}=a,{table:o,byvars:s}=a.appControl,l=a.state.columns;if(null===s||0===s.length)return null;let r=`proc sql; update ${o.libref}.${o.name}`,i="SET ",u=" ";for(const a in t)!1===l[a].custom&&(i=i+u+a+"="+p(t[a])),u=", ";r=r+" "+i;let c=" WHERE ",f=" ";s.forEach(a=>{c=c+f+a+"="+p(t[a]),f="AND "}),r=r+" "+c+";run;";const m={data:{code:r.split(/\r?\n/)}},d=await n.apiCall(e.links("execute"),m),w=await n.jobState(d,{qs:{newState:"Completed",timeout:1}});return{statusCode:"completed"===w.data?0:1,msg:w.data}}(a,n),e}function p(t){let a;return a=null==t?".":"string"==typeof t?JSON.stringify(t):t.toString(),a}async function w(t,a,n,e,o){let s=f({},e);const l=o.state.columns,{handlers:r,autoSave:i}=o.appControl.editControl;s[t]=function(t,a){let n=t;const e=a.Type.toLowerCase();return"string"!=typeof n||"decimal"!==e&&"number"!==e&&"double"!==e&&"float"!==e||(n=parseFloat(1*t),!0===isNaN(t)&&(t=0)),n}(a,l[t]);let u={statusCode:0,msg:""};if(null!=r[t]){const a=await r[t](s,t,n,o);if(s=a[0],u=a[1],2===u.statusCode)return{data:a[0],status:u}}let c=await m("main",s,n,o);if(!0===i){if(c=await m("term",c[0],n,o),u=c[1],2===u.statusCode)return{data:c[0],status:u};u=await d(c[0],o)}return s=c[0],!0===o.appControl.cachePolicy&&(o.state.data[e._rowIndex]=s),{data:s,status:u}}async function g(t,a){const{schema:n,rows:e}=t,o=a.appControl.customColumns;let s={statusCode:0,msg:"Initialization was successful"};const l=(t,a,n)=>{const e={_rowIndex:n};if(a.forEach((a,n)=>{const o=t[n].Column.toLowerCase();e[o]=a}),null!=o)for(const t in o){const a=o[t],n=a.Column.toLowerCase();e[n]=a.value}return e},r=[];for(let t=0;t<e.length;t++){const o=l(n,e[t],t),[i,u]=await m("init",o,t,a);s=u,r.push(i)}const i={};if(n.forEach((t,a)=>{const n=t.Column.toLowerCase();t.name=n,t.Label=null==t.Label||0===t.Label.length?t.Column:t.Label,null==t.Type&&(t.Type=null==t.type?"double":t.type),t.custom=!1,i[n]=t}),null!=o)for(const t in o){const a=f({},o[t]);a.name=t,a.custom=!0,i[t]=a}return{columns:i,data:r,status:s}}async function y(t,e){let o=null;return o="cas"===e.source?await async function(t,n){const{store:e,session:o}=n,s=f({},t);if(s.from<=0||-1===s.next)return null;null==s.where&&(s.where=" ");const l=await a(e,o,s);let r=null;return null!==l&&(r=await g(l.data,n),n.state={modified:[],pagination:f({},l.pagination),currentPage:s,data:[],columns:[]},!0===n.appControl.cachePolicy&&(n.state.data=r.data,n.state.columns=r.columns),r.pagination=f({},l.pagination)),r}(t,e):await async function(t,a){const{store:e,tableSummary:o}=a,{table:s}=a.appControl,l=`${s.libref}.${s.name}`.toLowerCase();let r={qs:{start:t.from-1,limit:t.count,format:null==t.format&&t.format}};const i=await n(e,o,l,null,r);let u=null;return null!==i&&(u=await g(i,a),a.state={modified:[],pagination:{},currentPage:{},data:u.data,columns:u.columns}),u}(t,e),o}async function C(t,e,o){let s;return s="cas"===e.source?await async function(t,n,e){const{store:o,session:s}=n,{initialFetch:l,table:r}=n.appControl;let i;if("first"===t)i=f({},l);else if(null!==t&&(i=f({},n.state.pagination[t]),-1===i.next||i.from<=0))return null;null!=e&&(i=f({},e)),i.table=r;const u=await a(o,s,i);let c=null;if(null!==u)return c=await g(u.data,n),n.state={modified:[],pagination:f({},u.pagination),currentPage:i,data:[],columns:[]},!0===n.appControl.cachePolicy&&(n.state.data=c.data,n.state.columns=c.columns),c.pagination=f({},u.pagination),c}(t,e,o):await async function(t,a,e){const{store:o,tableSummary:s}=a,{table:l,initialFetch:r}=a.appControl;let i=null;const u=`${l.libref}.${l.name}`.toLowerCase();null==e?"first"===t&&(i=f({},r)):i=f({},e);const c=await n(o,s,u,t,i);let m=null;return null!==c&&(m=await g(c,a),a.state={modified:[],pagination:{},currentPage:{},data:m.data,columns:m.columns}),m}(t,e,o),s}async function b(t,a,n){const l=u();let r;return null==t.authType&&(t.authType="code"),r="cas"===a.source?await async function(t,a,n){const o=await e(t,a);return{source:n.source,store:t,session:o.session,servers:o.servers,restaflib:null,logonPayload:a,appControl:n,state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}},id:Date()}}(l,t,a):await async function(t,a,n,e){let l=await o(t,n.computeContext,a),r=await s(t,l,n.table,e);return{source:n.source,store:t,session:l,tableSummary:r,servers:null,restaflib:null,logonPayload:a,appControl:c(n),state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}},id:Date()}}(l,t,a,n),r}async function h(t,a,n,e){let o;return o="cas"===n.source?await async function(t,a,n,e){const{store:o,session:s}=n,r={table:t,column:a},i=await l(o,s,"\n  results = selectionLists(_args_.column,_args_.table.caslib, _args_.table.name);\n  send_response({casResults = {data=results}});\n  ",r,!0);if(0!==i.results.casResults.data.statusCode)throw"Failed to create unique list";return i.results.casResults.data.data}(t,a,n):await async function(t,a,n){const e={};return e[t]=[],e}(t),o}async function v(t,a,n,e,o,s,l){const{store:i,session:u}=o;let c=a[0];for(let t=0;t<n.length;t++)delete c[n[t]];c=f({},e,c);const m=Object.keys(c);let d,p=m.join(",")+"\n";for(let t=0;t<a.length;t++){let n=a[t];n=f({},n,e);const o=[];m.forEach((t,a)=>{let e=n[t];"string"==typeof e&&(e=e.trim()),o[a]=e}),p=p+o.join(",")+"\n"}return console.log(p),console.log(r),console.log(P),d="cas"===o.source?await P(i,u,t,p,s,l):{},d}async function P(t,a,n,e,o,s){console.log("calling casUpload");const l=`${n.caslib}.${n.name}`;let u=await r(t,a,null,l,!0,e);if(console.log("end of casUpload"),null!=o)return u=await i(t,a,n,o,s),u}async function _(t,a,n){return[]}export{w as cellEdit,m as commonHandler,h as distinctValues,y as fetchTableRows,C as scrollTable,b as setup,_ as sort,d as updateTableRows,v as uploadData};
//# sourceMappingURL=index.modern.mjs.map
