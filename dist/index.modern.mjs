import{casUpdateData as t,casFetchRows as a,computeFetchData as n,casSetup as e,computeSetup as s,computeSetupTables as o,caslRun as l,casUpload as r}from"@sassoftware/restaflib";import{initStore as c}from"@sassoftware/restaf";import i from"deepmerge";function u(){return u=Object.assign?Object.assign.bind():function(t){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},u.apply(this,arguments)}async function d(t,a,n,e){const{handlers:s}=e.appControl.editControl;if(null==s[t])return[a,{statusCode:0,msg:null}];{const[o,l]=await s[t](a,n,e,t);return[o,l]}}async function f(a,n){let e;return e="cas"===n.source?await async function(a,n){const{store:e,session:s}=n,{table:o,byvars:l}=n.appControl,r=n.state.columns;if(null===l||0===l.length)return null;const c={};for(const t in a)"_index_"!==t&&"_rowIndex"!==t&&!1===r[t].custom&&(c[t]=a[t]);const i={};l.forEach(t=>{i[t]=c[t]});const u={table:o,data:c,where:i},d={statusCode:0,msg:"Save successful"};return"Normal"!==(await t(e,s,u)).items().toJS().disposition.severity&&(d.statusCode=2,d.msg=c.disposition.severity.reason),d}(a,n):await async function(t,a){const{store:n,session:e}=a,{table:s,byvars:o}=a.appControl,l=a.state.columns;if(null===o||0===o.length)return null;let r=`proc sql; update ${s.libref}.${s.name}`,c="SET ",i=" ";for(const a in t)!1===l[a].custom&&(c=c+i+a+"="+m(t[a])),i=", ";r=r+" "+c;let u=" WHERE ",d=" ";o.forEach(a=>{u=u+d+a+"="+m(t[a]),d="AND "}),r=r+" "+u+";run;";const f={data:{code:r.split(/\r?\n/)}},p=await n.apiCall(e.links("execute"),f),g=await n.jobState(p,{qs:{newState:"Completed",timeout:1}});return{statusCode:"completed"===g.data?0:1,msg:g.data}}(a,n),e}function m(t){let a;return a=null==t?".":"string"==typeof t?JSON.stringify(t):t.toString(),a}async function p(t,a,n,e,s){let o=u({},e);const l=s.state.columns,{handlers:r,autoSave:c}=s.appControl.editControl;o[t]=function(t,a){let n=t;const e=a.Type.toLowerCase();return"string"!=typeof n||"decimal"!==e&&"number"!==e&&"double"!==e&&"float"!==e||(n=parseFloat(1*t),!0===isNaN(t)&&(t=0)),n}(a,l[t]);let i={statusCode:0,msg:""};if(null!=r[t]){const a=await r[t](o,t,n,s);if(o=a[0],i=a[1],2===i.statusCode)return{data:a[0],status:i}}let m=await d("main",o,n,s);if(!0===c){if(m=await d("term",m[0],n,s),i=m[1],2===i.statusCode)return{data:m[0],status:i};i=await f(m[0],s)}return o=m[0],!0===s.appControl.cachePolicy&&(s.state.data[e._rowIndex]=o),{data:o,status:i}}async function g(t,a){const{schema:n,rows:e}=t,s=a.appControl.customColumns;let o={statusCode:0,msg:"Initialization was successful"};const l=(t,a,n)=>{const e={_rowIndex:n};if(a.forEach((a,n)=>{const s=t[n].Column.toLowerCase();e[s]=a}),null!=s)for(const t in s){const a=s[t],n=a.Column.toLowerCase();e[n]=a.value}return e},r=[];for(let t=0;t<e.length;t++){const s=l(n,e[t],t),[c,i]=await d("init",s,t,a);o=i,r.push(c)}const c={};if(n.forEach((t,a)=>{const n=t.Column.toLowerCase();t.name=n,t.Label=null==t.Label||0===t.Label.length?t.Column:t.Label,null==t.Type&&(t.Type=null==t.type?"double":t.type),t.custom=!1,c[n]=t}),null!=s)for(const t in s){const a=u({},s[t]);a.name=t,a.custom=!0,c[t]=a}return{columns:c,data:r,status:o}}async function b(t,e){let s=null;return s="cas"===e.source?await async function(t,n){const{store:e,session:s}=n,o=u({},t);if(o.from<=0||-1===o.next)return null;null==o.where&&(o.where=" ");const l=await a(e,s,o);let r=null;return null!==l&&(r=await g(l.data,n),n.state={modified:[],pagination:u({},l.pagination),currentPage:o,data:[],columns:[]},!0===n.appControl.cachePolicy&&(n.state.data=r.data,n.state.columns=r.columns),r.pagination=u({},l.pagination)),r}(t,e):await async function(t,a){const{store:e,tableSummary:s}=a,{table:o}=a.appControl,l=`${o.libref}.${o.name}`.toLowerCase();let r={qs:{start:t.from-1,limit:t.count,format:null==t.format&&t.format}};const c=await n(e,s,l,null,r);let i=null;return null!==c&&(i=await g(c,a),a.state={modified:[],pagination:{},currentPage:{},data:i.data,columns:i.columns}),i}(t,e),s}async function w(t,e,s){let o;return o="cas"===e.source?await async function(t,n,e){const{store:s,session:o}=n,{initialFetch:l,table:r}=n.appControl;let c;if("first"===t)c=u({},l);else if(null!==t&&(c=u({},n.state.pagination[t]),-1===c.next||c.from<=0))return null;null!=e&&(c=u({},e)),c.table=r;const i=await a(s,o,c);let d=null;if(null!==i)return d=await g(i.data,n),n.state={modified:[],pagination:u({},i.pagination),currentPage:c,data:[],columns:[]},!0===n.appControl.cachePolicy&&(n.state.data=d.data,n.state.columns=d.columns),d.pagination=u({},i.pagination),d}(t,e,s):await async function(t,a,e){const{store:s,tableSummary:o}=a,{table:l,initialFetch:r}=a.appControl;let c=null;const i=`${l.libref}.${l.name}`.toLowerCase();null==e?"first"===t&&(c=u({},r)):c=u({},e);const d=await n(s,o,i,t,c);let f=null;return null!==d&&(f=await g(d,a),a.state={modified:[],pagination:{},currentPage:{},data:f.data,columns:f.columns}),f}(t,e,s),o}async function y(t,a,n){const l=c();let r;return null==t.authType&&(t.authType="code"),r="cas"===a.source?await async function(t,a,n){const s=await e(t,a);return{source:n.source,store:t,session:s.session,servers:s.servers,restaflib:null,logonPayload:a,appControl:n,state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}},id:Date()}}(l,t,a):await async function(t,a,n,e){let l=await s(t,n.computeContext,a),r=await o(t,l,n.table,e);return{source:n.source,store:t,session:l,tableSummary:r,servers:null,restaflib:null,logonPayload:a,appControl:i(n),state:{modified:[],pagination:{},currentPage:{},data:{},columns:{}},id:Date()}}(l,t,a,n),r}async function C(t,a,n,e){let s;return s="cas"===n.source?await async function(t,a,n,e){const{store:s,session:o}=n,r={table:t,column:a},c=await l(s,o,"\n  results = selectionLists(_args_.column,_args_.table.caslib, _args_.table.name);\n  send_response({casResults = {data=results}});\n  ",r,!0);if(0!==c.results.casResults.data.statusCode)throw"Failed to create unique list";return c.results.casResults.data.data}(t,a,n):await async function(t,a,n){const e={};return e[t]=[],e}(t),s}async function h(t,a,n,e,s,o){const{store:l,session:c}=s;let i=a[0];for(let t=0;t<n.length;t++)delete i[n[t]];i=u({},e,i);const d=Object.keys(i);let f,m=d.join(",")+"\n";for(let t=0;t<a.length;t++){let n=a[t];n=u({},n,e);const s=[];d.forEach((t,a)=>{let e=n[t];"string"==typeof e&&(e=e.trim()),s[a]=e}),m=m+s.join(",")+"\n"}return console.log(m),console.log(r),console.log(_),f="cas"===s.source?await _(l,c,t,m,o):{},console.log(f.items().toJS()),f}async function _(t,a,n,e,s){console.log("calling casUpload");const o=`${n.caslib}.${n.name}`;let c=await r(t,a,null,o,!0,e);if(console.log("end of casUpload"),null!=s){const e={masterTable:s,setTable:n},r=`\n\t\t\trc = checkAndLoadTable(_args_.masterTable.caslib, _args_.masterTable.name);\n\t\t\tif (rc ne true) then do;\n\t\t\t\tresults = {Errors= 'Unable to access ' ||_args_.masterTable.caslib||'.'||_args_.masterTable.name};   \n\t\t\t\tsend_response(casResults=results);\n\t\t\t\tend; \n\t\t\trc = checkAndLoadTable(_args_.setTable.caslib, _args_.setTable.name);\n\t\t\tif (rc ne true) then do;\n\t\t\t\tresults = {Errors= 'Unable to access ' ||_args_.setTable.caslib||'.'||_args_.setTable.name};   \n\t\t\t\tsend_response(casResults=results);\n\t\t\t\tend;\n\t\t\taction datastep.runCode r=result rc=rc/ code='data ${s.caslib}.${s.name} (append=YES);set ${o};run;'\n\t\t\tsend_response({casResults = {code = rc}});\n\t\t\t`;return console.log(r),c=await l(t,a,r,e,!0),console.log(c),c}}async function T(t,a,n){return[]}export{p as cellEdit,d as commonHandler,C as distinctValues,b as fetchTableRows,w as scrollTable,y as setup,T as sort,f as updateTableRows,h as uploadData};
//# sourceMappingURL=index.modern.mjs.map
